"use strict";(self.webpackChunkelement_web=self.webpackChunkelement_web||[]).push([[5813],{"./node_modules/matrix-js-sdk/src/indexeddb-helpers.ts":(e,t,o)=>{function n(e,t){return new Promise(((o,n)=>{let s=!0;const r=e.open(t);r.onupgradeneeded=()=>{s=!1},r.onblocked=()=>n(r.error),r.onsuccess=()=>{r.result.close(),s||e.deleteDatabase(t),o(s)},r.onerror=()=>n(r.error)}))}o.d(t,{t:()=>n})},"./node_modules/matrix-js-sdk/src/store/indexeddb-local-backend.ts":(e,t,o)=>{o.d(t,{k:()=>m});var n=o("./node_modules/@babel/runtime/helpers/esm/defineProperty.js"),s=o("./node_modules/matrix-js-sdk/src/sync-accumulator.ts"),r=o("./node_modules/matrix-js-sdk/src/utils.ts"),a=o("./node_modules/matrix-js-sdk/src/indexeddb-helpers.ts"),c=o("./node_modules/matrix-js-sdk/src/logger.ts");const i=[e=>{e.createObjectStore("users",{keyPath:["userId"]}),e.createObjectStore("accountData",{keyPath:["type"]}),e.createObjectStore("sync",{keyPath:["clobber"]})},e=>{e.createObjectStore("oob_membership_events",{keyPath:["room_id","state_key"]}).createIndex("room","room_id")},e=>{e.createObjectStore("client_options",{keyPath:["clobber"]})},e=>{e.createObjectStore("to_device_queue",{autoIncrement:!0})}],d=i.length;function l(e,t,o){const n=e.openCursor(t);return new Promise(((e,t)=>{const s=[];n.onerror=()=>{t(new Error("Query failed: "+n.error))},n.onsuccess=()=>{const t=n.result;t?(s.push(o(t)),t.continue()):e(s)}}))}function u(e){return new Promise(((t,o)=>{e.oncomplete=function(e){t(e)},e.onerror=function(){o(e.error)}}))}function h(e){return new Promise(((t,o)=>{e.onsuccess=function(e){t(e)},e.onerror=function(){o(e.error)}}))}function b(e){return h(e).then((t=>e.result))}class m{static exists(e,t){return t="matrix-js-sdk:"+(t||"default"),(0,a.t)(e,t)}constructor(e,t="default"){(0,n.A)(this,"dbName",void 0),(0,n.A)(this,"syncAccumulator",void 0),(0,n.A)(this,"db",void 0),(0,n.A)(this,"disconnected",!0),(0,n.A)(this,"_isNewlyCreated",!1),(0,n.A)(this,"syncToDatabasePromise",void 0),(0,n.A)(this,"pendingUserPresenceData",[]),this.indexedDB=e,this.dbName="matrix-js-sdk:"+t,this.syncAccumulator=new s.w}connect(e){if(!this.disconnected)return c.v.log("LocalIndexedDBStoreBackend.connect: already connected or connecting"),Promise.resolve();this.disconnected=!1,c.v.log("LocalIndexedDBStoreBackend.connect: connecting...");const t=this.indexedDB.open(this.dbName,d);return t.onupgradeneeded=e=>{const o=t.result,n=e.oldVersion;c.v.log(`LocalIndexedDBStoreBackend.connect: upgrading from ${n}`),n<1&&(this._isNewlyCreated=!0),i.forEach(((e,t)=>{n<=t&&e(o)}))},t.onblocked=()=>{c.v.log("can't yet open LocalIndexedDBStoreBackend because it is open elsewhere")},c.v.log("LocalIndexedDBStoreBackend.connect: awaiting connection..."),h(t).then((async()=>{c.v.log("LocalIndexedDBStoreBackend.connect: connected"),this.db=t.result,this.db.onversionchange=()=>{var e;null===(e=this.db)||void 0===e||e.close(),this.disconnected=!0,this.db=void 0},this.db.onclose=()=>{this.disconnected=!0,this.db=void 0,null==e||e()},await this.init()}))}isNewlyCreated(){return Promise.resolve(this._isNewlyCreated)}init(){return Promise.all([this.loadAccountData(),this.loadSyncData()]).then((([e,t])=>{c.v.log("LocalIndexedDBStoreBackend: loaded initial data"),this.syncAccumulator.accumulate({next_batch:t.nextBatch,rooms:t.roomsData,account_data:{events:e}},!0)}))}getOutOfBandMembers(e){return new Promise(((t,o)=>{const n=this.db.transaction(["oob_membership_events"],"readonly").objectStore("oob_membership_events").index("room"),s=IDBKeyRange.only(e),r=n.openCursor(s),a=[];let c=!1;r.onsuccess=()=>{const e=r.result;if(!e)return a.length||c?t(a):t(null);const o=e.value;o.oob_written?c=!0:a.push(o),e.continue()},r.onerror=e=>{o(e)}})).then((t=>(c.v.log(`LL: got ${null==t?void 0:t.length} membershipEvents from storage for room ${e} ...`),t)))}async setOutOfBandMembers(e,t){c.v.log(`LL: backend about to store ${t.length} members for ${e}`);const o=this.db.transaction(["oob_membership_events"],"readwrite"),n=o.objectStore("oob_membership_events");t.forEach((e=>{n.put(e)}));const s={room_id:e,oob_written:!0,state_key:0};n.put(s),await u(o),c.v.log(`LL: backend done storing for ${e}!`)}async clearOutOfBandMembers(e){const t=this.db.transaction(["oob_membership_events"],"readonly").objectStore("oob_membership_events").index("room"),o=IDBKeyRange.only(e),n=b(t.openKeyCursor(o,"next")).then((e=>(null==e?void 0:e.primaryKey)[1])),s=b(t.openKeyCursor(o,"prev")).then((e=>(null==e?void 0:e.primaryKey)[1])),[r,a]=await Promise.all([n,s]),i=this.db.transaction(["oob_membership_events"],"readwrite").objectStore("oob_membership_events"),d=IDBKeyRange.bound([e,r],[e,a]);var l;c.v.log(`LL: Deleting all users + marker in storage for room ${e}, with key range:`,[e,r],[e,a]),await(l=i.delete(d),new Promise(((e,t)=>{l.onsuccess=()=>e(l),l.onerror=e=>t(e)})))}clearDatabase(){return new Promise((e=>{var t;c.v.log(`Removing indexeddb instance: ${this.dbName}`),null===(t=this.db)||void 0===t||t.close();const o=this.indexedDB.deleteDatabase(this.dbName);o.onblocked=()=>{c.v.log(`can't yet delete indexeddb ${this.dbName} because it is open elsewhere`)},o.onerror=()=>{c.v.warn(`unable to delete js-sdk store indexeddb: ${o.error}`),e()},o.onsuccess=()=>{c.v.log(`Removed indexeddb instance: ${this.dbName}`),e()}}))}getSavedSync(e=!0){const t=this.syncAccumulator.getJSON();return t.nextBatch?e?Promise.resolve((0,r.A4)(t)):Promise.resolve(t):Promise.resolve(null)}getNextBatchToken(){return Promise.resolve(this.syncAccumulator.getNextBatchToken())}setSyncData(e){return Promise.resolve().then((()=>{this.syncAccumulator.accumulate(e)}))}async syncToDatabase(e){return this.syncToDatabasePromise?(c.v.warn("Skipping syncToDatabase() as persist already in flight"),this.pendingUserPresenceData.push(...e),this.syncToDatabasePromise):(e.unshift(...this.pendingUserPresenceData),this.syncToDatabasePromise=this.doSyncToDatabase(e),this.syncToDatabasePromise)}async doSyncToDatabase(e){try{const t=this.syncAccumulator.getJSON(!0);await Promise.all([this.persistUserPresenceEvents(e),this.persistAccountData(t.accountData),this.persistSyncData(t.nextBatch,t.roomsData)])}finally{this.syncToDatabasePromise=void 0}}persistSyncData(e,t){return c.v.log("Persisting sync data up to",e),(0,r.j0)((()=>{const o=this.db.transaction(["sync"],"readwrite");return o.objectStore("sync").put({clobber:"-",nextBatch:e,roomsData:t}),u(o).then((()=>{c.v.log("Persisted sync data up to",e)}))}))}persistAccountData(e){return(0,r.j0)((()=>{const t=this.db.transaction(["accountData"],"readwrite"),o=t.objectStore("accountData");for(const t of e)o.put(t);return u(t).then()}))}persistUserPresenceEvents(e){return(0,r.j0)((()=>{const t=this.db.transaction(["users"],"readwrite"),o=t.objectStore("users");for(const t of e)o.put({userId:t[0],event:t[1]});return u(t).then()}))}getUserPresenceEvents(){return(0,r.j0)((()=>l(this.db.transaction(["users"],"readonly").objectStore("users"),void 0,(e=>[e.value.userId,e.value.event]))))}loadAccountData(){return c.v.log("LocalIndexedDBStoreBackend: loading account data..."),(0,r.j0)((()=>l(this.db.transaction(["accountData"],"readonly").objectStore("accountData"),void 0,(e=>e.value)).then((e=>(c.v.log("LocalIndexedDBStoreBackend: loaded account data"),e)))))}loadSyncData(){return c.v.log("LocalIndexedDBStoreBackend: loading sync data..."),(0,r.j0)((()=>l(this.db.transaction(["sync"],"readonly").objectStore("sync"),void 0,(e=>e.value)).then((e=>(c.v.log("LocalIndexedDBStoreBackend: loaded sync data"),e.length>1&&c.v.warn("loadSyncData: More than 1 sync row found."),e.length>0?e[0]:{})))))}getClientOptions(){return Promise.resolve().then((()=>l(this.db.transaction(["client_options"],"readonly").objectStore("client_options"),void 0,(e=>{var t;return null===(t=e.value)||void 0===t?void 0:t.options})).then((e=>e[0]))))}async storeClientOptions(e){const t=this.db.transaction(["client_options"],"readwrite");t.objectStore("client_options").put({clobber:"-",options:e}),await u(t)}async saveToDeviceBatches(e){const t=this.db.transaction(["to_device_queue"],"readwrite"),o=t.objectStore("to_device_queue");for(const t of e)o.add(t);await u(t)}async getOldestToDeviceBatch(){const e=this.db.transaction(["to_device_queue"],"readonly").objectStore("to_device_queue"),t=await b(e.openCursor());if(!t)return null;const o=t.value;return{id:t.key,txnId:o.txnId,eventType:o.eventType,batch:o.batch}}async removeToDeviceBatch(e){const t=this.db.transaction(["to_device_queue"],"readwrite");t.objectStore("to_device_queue").delete(e),await u(t)}async destroy(){var e;null===(e=this.db)||void 0===e||e.close()}}}}]);
//# sourceMappingURL=5813.js.map